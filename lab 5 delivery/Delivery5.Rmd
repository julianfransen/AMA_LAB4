---
title: 'Delivery 5: AMA'
author: "Marc Falc√≥n Barau, Julian Fransen, Victor Garcia Pizarro"
date: "2024-11-24"
output:
  html_document:
    toc: true
    toc_depth: '3'
    df_print: paged
editor_options:
  chunk_output_type: console
---

```{r include=FALSE}
setwd("~/uni_folder/AMA/AMA_LAB4/lab 5 delivery")
```

# Bandwidth choice for the local Poisson regression

In this part, we modify the `h.cv.sm.binomial` and `loglik.CV` functions to obtain a bandwidth choice method for the local Poisson regression based on the loo-CV estimation. We will use the formulas given by the instructions: 

For leave-one-out cross-validation estimation of the expected log-likelihood of an independent observation, when using $h$ as bandwidth, we use
\[
\ell_{CV}(h)
=\frac{1}{n}\sum_{i=1}^{n} \log\left( \widehat{\Pr}_h^{\tiny(-i)}(Y=y_i|X=x_i)\right),
\]
where $\widehat{\Pr}_h^{\tiny(-i)}(Y=y_i|X=x_i)$ is an estimation of
\[
\Pr(Y=y_i|X=x_i)=e^{-\lambda_i} \frac{\lambda_i^{y_i}}{y_i!},
\]
and 
\[
\lambda_i=\mathbb{E}(Y|X=x_i)
\]

```{r}
# Here,
h.cv.sm.poisson <- function(x,y,rg.h=NULL,l.h=10,method=loglik.CV){
   cv.h <- numeric(l.h)
   if (is.null(rg.h)){
      hh <- c(h.select(x,y,method="cv"),
              h.select(x,y,method="aicc"))#,hcv(x,y))
      rg.h <- range(hh)*c(1/1.1, 1.5)
   }
   i <- 0
   gr.h <- exp( seq(log(rg.h[1]), log(rg.h[2]), l=l.h))
   for (h in gr.h){
      i <- i+1
      cv.h[i] <- method(x,y,h)
   }
   return(list(h = gr.h, 
               cv.h = cv.h, 
               h.cv = gr.h[which.min(cv.h)]))
}

loglik.CV <- function(x, y, h) {
  n <- length(y)
  mean(sapply(1:n, function(i) {
    # Estimate lambda for the i-th observation
    lambda_i <- sm.poisson(x = x[-i], y = y[-i], h = h, eval.points = x[i], display = "none")$estimate
    # Compute log-likelihood for the i-th observation
    log(dpois(y[i], lambda = lambda_i))
  }))
}
```

In the code you can see that I copied the code for `h.cv.sm.poisson` completely from the `h.cv.sm.binomial` found in the lab. The only thing I changed is the name. However, the code for `loglik.CV` is changed significantly. I calculate the $\lambda_i$ based on the formulas, where I use the `sm.poisson` function to obtain the estimate. Then I use the mean, which is equivalent to the sum divided by n part of the formula. 


# Local Poisson regression for Country Development Data

Now we apply the modified functions to the country development dataset to find the optimal value of h, the smoothing parameter. The target value is `le.fm.r`, which is the rounded value of `le.fm` and the explanatory variable is `Life.expec`. This code is again based on the code seen in lab. 

```{r include=FALSE}
# Load data and libraries
countries<-read.csv2(file="HDI.2017.subset.csv",row.names = 1)
attach(countries)
library(sm)

# Round the float value so we can use Poisson modelling
countries$le.fm.r <-  round(countries$le.fm)
x <- countries$Life.expec
y <- countries$le.fm.r
```

For the range of h we use ...... Let's run and plot the results.

```{r}
# using h.CV.loglik

R <- range(x)[2] - range(x)[1]
h_min <- R / 10
h_max <- R / 2
x_scaled <- scale(x)


h.CV.loglik <- h.cv.sm.poisson(x_scaled,y,rg.h=c(h_min,h_max),method=loglik.CV)
plot(h.CV.loglik$h,h.CV.loglik$cv.h)
lines(h.CV.loglik$h,h.CV.loglik$cv.h)
```

